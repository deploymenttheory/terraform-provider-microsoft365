#!/usr/bin/env python3
"""
Creates individual GitHub issues for each failing test.
Usage: ./create-test-issues.py <owner> <repo> <run-id> <failures-json>
"""

import sys
import json
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional


def run_gh_command(args: List[str]) -> str:
    """Run a GitHub CLI command and return output."""
    try:
        result = subprocess.run(
            ["gh"] + args,
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error running gh command: {e.stderr}", file=sys.stderr)
        raise


def find_existing_issue(owner: str, repo: str, test_name: str) -> Optional[str]:
    """Check if an issue already exists for this test failure."""
    try:
        result = run_gh_command([
            "issue", "list",
            "--repo", f"{owner}/{repo}",
            "--state", "open",
            "--label", "test-failure",
            "--search", f'in:title "Test Failure: {test_name}"',
            "--json", "number,title",
            "--jq", ".[0].number"
        ])
        return result if result and result != "null" else None
    except Exception:
        return None


def update_existing_issue(owner: str, repo: str, issue_number: str, 
                         test_name: str, service_path: str, context: str, 
                         date: str, run_id: str, workflow_url: str) -> None:
    """Add a comment to existing issue indicating recurring failure."""
    comment_body = f"""## Test Failure Update: Recurring

**Date:** {date}  
**Workflow Run:** [{run_id}]({workflow_url})  
**Service Path:** `{service_path}`

### Latest Failure Context

```
{context}
```

### Assessment

This test has failed again in the latest nightly run. Possible causes:
- Unresolved issue from previous occurrence
- New regression introduced
- Flaky test (environment instability)
- Test requires maintenance/update

**Next Steps:** 
1. Review failure pattern to determine if this is a persistent issue
2. If persistent (3+ consecutive failures), consider escalating to incident
3. If intermittent, investigate flaky test root cause

---
*Automated update by test monitoring system*"""
    
    # Add comment
    run_gh_command([
        "issue", "comment", issue_number,
        "--repo", f"{owner}/{repo}",
        "--body", comment_body
    ])
    
    # Add recurring label
    run_gh_command([
        "issue", "edit", issue_number,
        "--repo", f"{owner}/{repo}",
        "--add-label", "recurring"
    ])
    
    print(f"Updated test failure report #{issue_number}")


def create_new_issue(owner: str, repo: str, test_name: str, 
                    service_path: str, context: str, date: str, 
                    run_id: str, workflow_url: str) -> str:
    """Create a new issue for test failure."""
    issue_title = f"Test Failure: {test_name}"
    
    issue_body = f"""<!-- Automated test failure report generated by nightly test pipeline -->

## Test Failure Report

**Status:** Under Investigation  
**Test Name:** `{test_name}`  
**Service Area:** `{service_path}`  
**First Detected:** {date}  
**Workflow Run:** [{run_id}]({workflow_url})

## Failure Details

### Test Information

- **Test Path:** `{test_name}`
- **Test Type:** Acceptance Test
- **Service:** {service_path}
- **Failure Pattern:** First Occurrence

### Failure Context

```
{context}
```

## Impact Assessment

**Pre-Production Environment:**
- ⚠️ Test suite quality gate failing
- ⚠️ Potential regression if deployed to production
- ✅ No customer impact (pre-production only)

**Severity Classification:**
- **Not Yet an Incident** - No production service disruption
- **Could Escalate** - If persists or blocks critical deployments

## Investigation Required

### Initial Analysis Checklist

- [ ] Review [workflow logs]({workflow_url}) for details
- [ ] Identify root cause (code change, environment, flaky test)
- [ ] Determine severity and regression risk
- [ ] Check if this affects production release readiness

### Classification Decision

After investigation, classify this failure:

- [ ] **Flaky Test** - Intermittent failure, test needs improvement
- [ ] **Environment Issue** - Test infrastructure problem
- [ ] **Genuine Bug** - Code defect requiring fix
- [ ] **Test Maintenance** - Test needs updating for new behavior

### Escalation Criteria

**Escalate to INCIDENT if:**
- Test fails 3+ consecutive times (persistent failure)
- Failure blocks critical production deployment
- Failure indicates production service degradation
- Security or data integrity concern

## Resolution Actions

- [ ] Fix identified root cause
- [ ] Verify fix locally and in CI/CD
- [ ] Document findings
- [ ] Close report when test passes
- [ ] Update test if maintenance needed

## Resources

- [View Workflow Run]({workflow_url})
- [View Test Coverage](https://codecov.io/gh/{owner}/{repo})
- [Test Source Code](../../)

---

**Management Notes:**

This is a test failure report, not an incident. It will be automatically updated if the test continues to fail.

**Closure Criteria:**
- Test passes in subsequent nightly run
- Root cause identified and documented
- OR classified as `wontfix` with justification

*Automated report by test monitoring system*"""
    
    issue_url = run_gh_command([
        "issue", "create",
        "--repo", f"{owner}/{repo}",
        "--title", issue_title,
        "--body", issue_body,
        "--label", "test-failure,automated,needs-triage"
    ])
    
    return issue_url


def process_test_failures(owner: str, repo: str, run_id: str, 
                         failures_json_path: str) -> None:
    """Process test failures and create or update issues."""
    # Validate inputs
    if not all([owner, repo, run_id]):
        print("Usage: create-test-issues.py <owner> <repo> <run-id> <failures-json>", 
              file=sys.stderr)
        print("Example: create-test-issues.py deploymenttheory terraform-provider-microsoft365 123456 test-failures.json", 
              file=sys.stderr)
        sys.exit(1)
    
    # Check if failures file exists
    failures_path = Path(failures_json_path)
    if not failures_path.exists():
        print(f"Error: Failures JSON file not found: {failures_json_path}", 
              file=sys.stderr)
        sys.exit(1)
    
    # Load failures
    with open(failures_path) as f:
        failures = json.load(f)
    
    failure_count = len(failures)
    
    if failure_count == 0:
        print("✅ No test failures found")
        return
    
    print(f"Found {failure_count} failing test(s)")
    
    date = datetime.utcnow().strftime("%Y-%m-%d")
    workflow_url = f"https://github.com/{owner}/{repo}/actions/runs/{run_id}"
    
    # Process each failure
    for failure in failures:
        test_name = failure["test_name"]
        category = failure["category"]
        service = failure["service"]
        context = failure["context"]
        
        # Build service path
        service_path = category
        if service and service != "null":
            service_path = f"{category}/{service}"
        
        print(f"\nProcessing failure: {test_name}")
        
        # Check for existing issue
        print("Checking for existing test failure report...")
        existing_issue = find_existing_issue(owner, repo, test_name)
        
        if existing_issue:
            print(f"Test failure report already exists: #{existing_issue}")
            print("Updating with latest occurrence...")
            update_existing_issue(
                owner, repo, existing_issue, test_name, 
                service_path, context, date, run_id, workflow_url
            )
        else:
            print("Creating new test failure report...")
            issue_url = create_new_issue(
                owner, repo, test_name, service_path, 
                context, date, run_id, workflow_url
            )
            print(f"Created test failure report: {issue_url}")
    
    print(f"\nTest failure processing complete: {failure_count} test failure(s) reported")


def main():
    if len(sys.argv) < 4:
        print("Usage: create-test-issues.py <owner> <repo> <run-id> [failures-json]", 
              file=sys.stderr)
        sys.exit(1)
    
    owner = sys.argv[1]
    repo = sys.argv[2]
    run_id = sys.argv[3]
    failures_json = sys.argv[4] if len(sys.argv) > 4 else "test-failures.json"
    
    process_test_failures(owner, repo, run_id, failures_json)


if __name__ == "__main__":
    main()

