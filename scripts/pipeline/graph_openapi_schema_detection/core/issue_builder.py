"""GitHub issue content builder for OpenAPI schema changes."""

from datetime import datetime
from typing import List, TYPE_CHECKING

if TYPE_CHECKING:
    from models import SchemaChange


class IssueBuilder:
    """Builds GitHub issue content from OpenAPI changes."""
    
    OPENAPI_REPO = "microsoftgraph/msgraph-metadata"
    
    def __init__(self, openapi_repo: str = OPENAPI_REPO):
        """Initialize issue builder.
        
        Args:
            openapi_repo: OpenAPI metadata repository
        """
        self.openapi_repo = openapi_repo
    
    def build_title(self, spec_version: str, old_version: str) -> str:
        """Build issue title.
        
        Args:
            spec_version: New OpenAPI spec version
            old_version: Previous OpenAPI spec version
            
        Returns:
            Issue title
        """
        return f"API Schema Update Required: Microsoft Graph OpenAPI {old_version} ‚Üí {spec_version}"
    
    def build_body(
        self,
        spec_version: str,
        old_version: str,
        schema_changes: List['SchemaChange']
    ) -> str:
        """Build issue body with property changes.
        
        Args:
            spec_version: New OpenAPI spec version
            old_version: Previous OpenAPI spec version
            schema_changes: List of schema changes
            
        Returns:
            Issue body in markdown
        """
        breaking_count = sum(1 for sc in schema_changes if sc.has_breaking_changes)
        
        body_parts = [
            "## Summary",
            "",
            f"The Microsoft Graph Beta API OpenAPI specification has been updated from `{old_version}` to `{spec_version}`. "
            f"This update includes **{len(schema_changes)}** schema(s) with changes that affect provider-managed resources.",
            "",
        ]
        
        if breaking_count > 0:
            body_parts.extend([
                f"‚ö†Ô∏è **{breaking_count} schema(s) have breaking changes** (removed properties, type changes, or new required fields).",
                "",
            ])
        
        body_parts.extend([
            "## Changed Schemas",
            "",
        ])
        
        # Group by breaking vs non-breaking
        breaking_schemas = [sc for sc in schema_changes if sc.has_breaking_changes]
        non_breaking_schemas = [sc for sc in schema_changes if not sc.has_breaking_changes]
        
        if breaking_schemas:
            body_parts.extend([
                "### ‚ö†Ô∏è Breaking Changes",
                "",
            ])
            for schema in breaking_schemas:
                body_parts.extend(self._format_schema_change(schema, show_all=True))
        
        if non_breaking_schemas:
            body_parts.extend([
                "",
                "### ‚úÖ Non-Breaking Changes",
                "",
            ])
            for schema in non_breaking_schemas:
                body_parts.extend(self._format_schema_change(schema, show_all=False))
        
        body_parts.extend([
            "",
            "## Action Required",
            "",
            "1. **Review each changed schema** listed above",
            "2. **Update Terraform resource/datasource schemas** to match API changes",
            "3. **Update CRUD operations** - Adjust field mappings in Create/Read/Update/Delete functions",
            "4. **Handle breaking changes**:",
            "   - Removed properties: Deprecate in Terraform schema, add migration guide",
            "   - Type changes: Update schema type, may require version bump",
            "   - New required fields: Update validation, may require version bump",
            "5. **Test thoroughly** - Run acceptance tests for all affected resources",
            "6. **Update documentation** - Document any breaking changes or new fields",
            "",
            "## References",
            "",
            f"- [OpenAPI Spec Repository](https://github.com/{self.openapi_repo})",
            f"- [OpenAPI Spec File](https://github.com/{self.openapi_repo}/blob/master/openapi/beta/openapi.yaml)",
            "",
            "---",
            f"ü§ñ Auto-generated by OpenAPI schema detection on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        ])
        
        return "\n".join(body_parts)
    
    def _format_schema_change(self, schema: 'SchemaChange', show_all: bool = True) -> List[str]:
        """Format a single schema change.
        
        Args:
            schema: Schema change
            show_all: If True, show all properties; if False, limit to first 5
            
        Returns:
            List of markdown lines
        """
        lines = [
            f"### `{schema.schema_name}`",
            "",
            f"**Changes:** {schema.change_summary}",
            "",
        ]
        
        # Added properties
        if schema.added_properties:
            lines.append("**Added Properties:**")
            props_to_show = schema.added_properties if show_all else schema.added_properties[:5]
            for prop in props_to_show:
                req_marker = "* " if prop.new_required else "  "
                
                # Build property line with metadata
                prop_line = f"- {req_marker}`{prop.property_name}`: `{prop.new_type}`"
                
                # Add metadata hints
                metadata_hints = []
                if prop.read_only:
                    metadata_hints.append("read-only")
                if prop.write_only:
                    metadata_hints.append("write-only")
                if prop.deprecated:
                    metadata_hints.append("‚ö†Ô∏è deprecated")
                if prop.enum_values:
                    enum_str = ', '.join(prop.enum_values[:3])
                    if len(prop.enum_values) > 3:
                        enum_str += f", +{len(prop.enum_values) - 3} more"
                    metadata_hints.append(f"enum: [{enum_str}]")
                if prop.format:
                    metadata_hints.append(f"format: {prop.format}")
                if prop.pattern:
                    metadata_hints.append(f"pattern: `{prop.pattern}`")
                if prop.min_length or prop.max_length:
                    if prop.min_length and prop.max_length:
                        metadata_hints.append(f"length: {prop.min_length}-{prop.max_length}")
                    elif prop.min_length:
                        metadata_hints.append(f"min: {prop.min_length}")
                    elif prop.max_length:
                        metadata_hints.append(f"max: {prop.max_length}")
                
                if metadata_hints:
                    prop_line += f" _({', '.join(metadata_hints)})_"
                
                lines.append(prop_line)
                
                # Add description if available
                if prop.description and len(prop.description) > 0:
                    desc = prop.description[:100] + "..." if len(prop.description) > 100 else prop.description
                    lines.append(f"  > {desc}")
            
            if not show_all and len(schema.added_properties) > 5:
                lines.append(f"- ... and {len(schema.added_properties) - 5} more")
            lines.append("")
        
        # Removed properties (always show all)
        if schema.removed_properties:
            lines.append("**‚ö†Ô∏è Removed Properties:**")
            for prop in schema.removed_properties:
                lines.append(f"- `{prop.property_name}`: `{prop.old_type}`")
            lines.append("")
        
        # Type changes (always show all)
        if schema.type_changed_properties:
            lines.append("**‚ö†Ô∏è Type Changes:**")
            for prop in schema.type_changed_properties:
                lines.append(f"- `{prop.property_name}`: `{prop.old_type}` ‚Üí `{prop.new_type}`")
            lines.append("")
        
        # Required changes (always show all)
        if schema.required_changed_properties:
            lines.append("**Required Status Changes:**")
            for prop in schema.required_changed_properties:
                old_status = "required" if prop.old_required else "optional"
                new_status = "required" if prop.new_required else "optional"
                marker = "‚ö†Ô∏è " if prop.new_required and not prop.old_required else ""
                lines.append(f"- {marker}`{prop.property_name}`: {old_status} ‚Üí {new_status}")
            lines.append("")
        
        return lines
