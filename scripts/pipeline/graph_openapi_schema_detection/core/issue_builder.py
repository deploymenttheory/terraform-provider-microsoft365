"""GitHub issue content builder for OpenAPI schema changes."""

from datetime import datetime
from typing import List, TYPE_CHECKING

if TYPE_CHECKING:
    from models import SchemaChange


class IssueBuilder:
    """Builds GitHub issue content from OpenAPI changes."""
    
    OPENAPI_REPO = "microsoftgraph/msgraph-metadata"
    
    def __init__(self, openapi_repo: str = OPENAPI_REPO):
        """Initialize issue builder.
        
        Args:
            openapi_repo: OpenAPI metadata repository
        """
        self.openapi_repo = openapi_repo
    
    def build_title(self, spec_version: str, old_version: str) -> str:
        """Build issue title.
        
        Args:
            spec_version: New OpenAPI spec version
            old_version: Previous OpenAPI spec version
            
        Returns:
            Issue title
        """
        return f"API Schema Update Required: Microsoft Graph OpenAPI {old_version} ‚Üí {spec_version}"
    
    def build_body(
        self,
        spec_version: str,
        old_version: str,
        schema_changes: List['SchemaChange']
    ) -> str:
        """Build issue body with property changes.
        
        Args:
            spec_version: New OpenAPI spec version
            old_version: Previous OpenAPI spec version
            schema_changes: List of schema changes
            
        Returns:
            Issue body in markdown
        """
        breaking_count = sum(1 for sc in schema_changes if sc.has_breaking_changes)
        
        body_parts = [
            "## Summary",
            "",
            f"The Microsoft Graph Beta API OpenAPI specification has been updated from `{old_version}` to `{spec_version}`. "
            f"This update includes **{len(schema_changes)}** schema(s) with changes that affect provider-managed resources.",
            "",
        ]
        
        if breaking_count > 0:
            body_parts.extend([
                f"‚ö†Ô∏è **{breaking_count} schema(s) have breaking changes** (removed properties, type changes, or new required fields).",
                "",
            ])
        
        body_parts.extend([
            "## Changed Schemas",
            "",
        ])
        
        # Group by breaking vs non-breaking
        breaking_schemas = [sc for sc in schema_changes if sc.has_breaking_changes]
        non_breaking_schemas = [sc for sc in schema_changes if not sc.has_breaking_changes]
        
        if breaking_schemas:
            body_parts.extend([
                "### ‚ö†Ô∏è Breaking Changes",
                "",
            ])
            for schema in breaking_schemas:
                body_parts.extend(self._format_schema_change(schema))
        
        if non_breaking_schemas:
            body_parts.extend([
                "",
                "### ‚úÖ Non-Breaking Changes",
                "",
            ])
            for schema in non_breaking_schemas:
                body_parts.extend(self._format_schema_change(schema))
        
        body_parts.extend([
            "",
            "## Action Required",
            "",
            "1. **Review each changed schema** listed above",
            "2. **Update Terraform resource/datasource schemas** to match API changes",
            "3. **Update CRUD operations** - Adjust field mappings in Create/Read/Update/Delete functions",
            "4. **Handle breaking changes**:",
            "   - Removed properties: Deprecate in Terraform schema, add migration guide",
            "   - Type changes: Update schema type, may require version bump",
            "   - New required fields: Update validation, may require version bump",
            "5. **Test thoroughly** - Run acceptance tests for all affected resources",
            "6. **Update documentation** - Document any breaking changes or new fields",
            "",
            "## References",
            "",
            f"- [OpenAPI Spec Repository](https://github.com/{self.openapi_repo})",
            f"- [OpenAPI Spec File](https://github.com/{self.openapi_repo}/blob/master/openapi/beta/openapi.yaml)",
            "",
            "---",
            f"ü§ñ Auto-generated by OpenAPI schema detection on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        ])
        
        return "\n".join(body_parts)
    
    def _format_schema_change(self, schema: 'SchemaChange') -> List[str]:
        """Format a single schema change.
        
        Args:
            schema: Schema change
            
        Returns:
            List of markdown lines
        """
        lines = [
            f"## `{schema.schema_name}`",
            "",
            f"**Summary:** {schema.change_summary}",
            f"**File:** `{schema.file_path}` _(for reference)_",
        ]
        
        # Show parent schemas (inheritance)
        if schema.parent_schemas:
            parent_list = ', '.join(f'`{p}`' for p in schema.parent_schemas)
            lines.append(f"**Inherits From:** {parent_list}")
        
        # Show discriminator for polymorphic types
        if schema.discriminator_value:
            disc_prop = schema.discriminator_property or '@odata.type'
            lines.append(f"**Polymorphic Type:** `{disc_prop}` = `{schema.discriminator_value}`")
        
        # Show schema-level description if available
        if schema.description and schema.description.strip():
            # Truncate long descriptions
            desc = schema.description.strip()
            if len(desc) > 200:
                desc = desc[:197] + "..."
            lines.append(f"**Description:** {desc}")
        
        lines.append("")
        
        # Added properties
        if schema.added_properties:
            lines.append("**Added Properties:**")
            lines.append("")
            for prop in schema.added_properties:
                req_marker = "**[Required]** " if prop.new_required else ""
                nullable_marker = " _(nullable)_" if prop.new_nullable else ""
                
                # Property header
                lines.append(f"#### ‚ûï `{prop.property_name}`")
                lines.append(f"- **Type:** `{prop.new_type}`{nullable_marker}")
                if req_marker:
                    lines.append(f"- {req_marker}")
                
                # Navigation property indicator (appears right after type)
                if prop.is_navigation_property:
                    lines.append(f"- **Relationship:** üîó Navigation property (references related entity)")
                
                # Description (always show, even if empty)
                if prop.description and prop.description.strip():
                    lines.append(f"- **Description:** {prop.description}")
                else:
                    lines.append("- **Description:** _(No description available in OpenAPI spec)_")
                
                # Enum values
                if prop.enum_values:
                    enum_display = ', '.join(f'`{str(v)}`' for v in prop.enum_values[:10])
                    if len(prop.enum_values) > 10:
                        enum_display += f' _(+{len(prop.enum_values) - 10} more)_'
                    lines.append(f"- **Allowed Values:** {enum_display}")
                
                # Validation constraints
                constraints = []
                if prop.format:
                    constraints.append(f"format: `{prop.format}`")
                if prop.pattern:
                    constraints.append(f"pattern: `{prop.pattern}`")
                if prop.min_length is not None or prop.max_length is not None:
                    if prop.min_length and prop.max_length:
                        constraints.append(f"length: {prop.min_length}-{prop.max_length}")
                    elif prop.min_length:
                        constraints.append(f"min length: {prop.min_length}")
                    elif prop.max_length:
                        constraints.append(f"max length: {prop.max_length}")
                if prop.minimum is not None or prop.maximum is not None:
                    if prop.minimum and prop.maximum:
                        constraints.append(f"range: {prop.minimum}-{prop.maximum}")
                    elif prop.minimum:
                        constraints.append(f"min: {prop.minimum}")
                    elif prop.maximum:
                        constraints.append(f"max: {prop.maximum}")
                
                if constraints:
                    lines.append(f"- **Constraints:** {', '.join(constraints)}")
                
                # Default value
                if prop.default is not None:
                    lines.append(f"- **Default:** `{prop.default}`")
                
                # Example
                if prop.example is not None:
                    lines.append(f"- **Example:** `{prop.example}`")
                
                # Flags
                flags = []
                if prop.read_only:
                    flags.append("read-only")
                if prop.write_only:
                    flags.append("write-only")
                if prop.deprecated:
                    flags.append("‚ö†Ô∏è **deprecated**")
                
                if flags:
                    lines.append(f"- **Flags:** {', '.join(flags)}")
                
                lines.append("")
            
            lines.append("")
        
        # Removed properties (always show all)
        if schema.removed_properties:
            lines.append("**‚ö†Ô∏è Removed Properties (Breaking Change):**")
            lines.append("")
            for prop in schema.removed_properties:
                req_marker = "**[Was Required]** " if prop.old_required else ""
                lines.append(f"#### ‚ûñ `{prop.property_name}`")
                lines.append(f"- **Type:** `{prop.old_type}`")
                if req_marker:
                    lines.append(f"- {req_marker}")
                
                # Navigation property indicator
                if prop.is_navigation_property:
                    lines.append(f"- **Was Relationship:** üîó Navigation property")
                
                # Show enum values if it was an enum
                if prop.enum_values:
                    enum_display = ', '.join(f'`{str(v)}`' for v in prop.enum_values[:10])
                    if len(prop.enum_values) > 10:
                        enum_display += f' _(+{len(prop.enum_values) - 10} more)_'
                    lines.append(f"- **Had Allowed Values:** {enum_display}")
                
                lines.append(f"- **Action Required:** Remove from Terraform schema, add deprecation notice if recently removed")
                lines.append("")
            lines.append("")
        
        # Type changes (always show all)
        if schema.type_changed_properties:
            lines.append("**‚ö†Ô∏è Type Changes (Breaking Change):**")
            lines.append("")
            for prop in schema.type_changed_properties:
                lines.append(f"#### üîÑ `{prop.property_name}`")
                lines.append(f"- **Old Type:** `{prop.old_type}`")
                lines.append(f"- **New Type:** `{prop.new_type}`")
                
                # Navigation property indicator
                if prop.is_navigation_property:
                    lines.append(f"- **Relationship:** üîó Navigation property")
                
                if prop.old_description and prop.old_description != prop.new_description:
                    lines.append(f"- **Old Description:** {prop.old_description}")
                if prop.new_description:
                    lines.append(f"- **New Description:** {prop.new_description}")
                
                # Show enum values if it has them
                if prop.enum_values:
                    enum_display = ', '.join(f'`{str(v)}`' for v in prop.enum_values[:10])
                    if len(prop.enum_values) > 10:
                        enum_display += f' _(+{len(prop.enum_values) - 10} more)_'
                    lines.append(f"- **Allowed Values:** {enum_display}")
                
                lines.append(f"- **Action Required:** Update Terraform schema type, may require provider version bump")
                lines.append("")
            lines.append("")
        
        # Required changes (always show all)
        if schema.required_changed_properties:
            lines.append("**Required Status Changes:**")
            lines.append("")
            for prop in schema.required_changed_properties:
                old_status = "required" if prop.old_required else "optional"
                new_status = "required" if prop.new_required else "optional"
                is_breaking = prop.new_required and not prop.old_required
                marker = "‚ö†Ô∏è " if is_breaking else "‚úÖ "
                
                lines.append(f"#### {marker}`{prop.property_name}`")
                lines.append(f"- **Change:** {old_status} ‚Üí {new_status}")
                if prop.description:
                    lines.append(f"- **Description:** {prop.description}")
                if is_breaking:
                    lines.append(f"- **‚ö†Ô∏è Breaking Change:** Field is now required")
                    lines.append(f"- **Action Required:** Update validation, add default if possible, may require version bump")
                else:
                    lines.append(f"- **Action Required:** Update validation (field now optional)")
                lines.append("")
            lines.append("")
        
        return lines
