name: PR Coverage Report

permissions:
  contents: read
  pull-requests: write

on:
  pull_request:
    paths:
      - '**/*.go'
      - 'go.mod'
      - 'go.sum'

jobs:
  coverage:
    name: 'ðŸ“Š Generate Coverage Report'
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 60
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Check Out
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: 'go.sum'
          cache: true

      - name: Install dependencies
        run: go mod download

      # Step 1: Identify all changed packages
      - name: Identify changed packages
        id: changed-packages
        run: |
          # Get list of changed .go files
          CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD | grep -E '\.(go)$' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No Go files changed"
            echo "packages=" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changed Go files:"
          echo "$CHANGED_FILES"

          # Extract unique package directories from changed files
          ALL_PACKAGES=$(echo "$CHANGED_FILES" | xargs -I {} dirname {} | sort -u)

          echo "All changed packages:"
          echo "$ALL_PACKAGES"

          # Convert to space-separated list for output
          PACKAGES_LIST=$(echo "$ALL_PACKAGES" | tr '\n' ' ' | sed 's/ $//')

          echo "packages<<EOF" >> $GITHUB_OUTPUT
          echo "$PACKAGES_LIST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT

      # Step 2: Determine service area for changed files
      - name: Determine service area
        id: service-area
        if: steps.changed-packages.outputs.has-changes == 'true'
        run: |
          PACKAGES="${{ steps.changed-packages.outputs.packages }}"
          SERVICE_AREAS=""

          for pkg in $PACKAGES; do
            # Check if package is in a service directory
            if [[ "$pkg" =~ internal/services/resources/([^/]+) ]]; then
              SERVICE="${BASH_REMATCH[1]}"
              if [[ ! "$SERVICE_AREAS" =~ "$SERVICE" ]]; then
                SERVICE_AREAS="$SERVICE_AREAS $SERVICE"
              fi
            elif [[ "$pkg" =~ internal/services/datasources/([^/]+) ]]; then
              SERVICE="${BASH_REMATCH[1]}"
              if [[ ! "$SERVICE_AREAS" =~ "$SERVICE" ]]; then
                SERVICE_AREAS="$SERVICE_AREAS $SERVICE"
              fi
            elif [[ "$pkg" =~ internal/(client|helpers|provider|utilities) ]]; then
              if [[ ! "$SERVICE_AREAS" =~ "provider-core" ]]; then
                SERVICE_AREAS="$SERVICE_AREAS provider-core"
              fi
            fi
          done

          SERVICE_AREAS=$(echo "$SERVICE_AREAS" | xargs)
          echo "Service areas affected: $SERVICE_AREAS"
          echo "service-areas=$SERVICE_AREAS" >> $GITHUB_OUTPUT

      # Step 3: Run unit tests with coverage for changed packages
      - name: Run unit tests with coverage
        if: steps.changed-packages.outputs.has-changes == 'true'
        run: |
          PACKAGES_WITH_TESTS="${{ steps.changed-packages.outputs.packages }}"

          if [ -z "$PACKAGES_WITH_TESTS" ]; then
            echo "No packages with tests to run"
            exit 0
          fi

          echo "Running unit tests with coverage for changed packages..."
          mkdir -p coverage

          # Run tests and generate coverage
          echo "$PACKAGES_WITH_TESTS" | xargs -I {} sh -c 'echo "Testing package: {}" && TF_ACC=0 go test -v -coverprofile=coverage/{}.out -covermode=atomic {} || true'

          # Merge all coverage files
          echo "mode: atomic" > coverage/unit-coverage.txt
          find coverage -name "*.out" -type f | while read file; do
            tail -n +2 "$file" >> coverage/unit-coverage.txt
          done

          echo "âœ… Unit test coverage generated"

      # Step 4: Upload unit test coverage to Codecov
      - name: Upload unit test coverage
        if: steps.changed-packages.outputs.has-changes == 'true'
        uses: codecov/codecov-action@671740ac38dd9b0130fbe1cec585b89eea48d3de # v5.5.2
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/unit-coverage.txt
          flags: unittests,pr-changes
          name: pr-unit-coverage
          fail_ci_if_error: false

      # Step 5: Generate coverage summary for PR comment
      - name: Generate coverage summary
        if: steps.changed-packages.outputs.has-changes == 'true'
        id: coverage-summary
        run: |
          if [ ! -f coverage/unit-coverage.txt ]; then
            echo "No coverage file found"
            exit 0
          fi

          # Calculate coverage percentage
          TOTAL_LINES=$(grep -v "^mode:" coverage/unit-coverage.txt | awk '{s+=$3}END{print s}' || echo "0")
          COVERED_LINES=$(grep -v "^mode:" coverage/unit-coverage.txt | awk '{s+=$2}END{print s}' || echo "0")

          if [ "$TOTAL_LINES" -gt 0 ]; then
            COVERAGE_PCT=$(awk "BEGIN {printf \"%.2f\", ($COVERED_LINES/$TOTAL_LINES)*100}")
          else
            COVERAGE_PCT="0.00"
          fi

          echo "coverage-pct=$COVERAGE_PCT" >> $GITHUB_OUTPUT
          echo "total-lines=$TOTAL_LINES" >> $GITHUB_OUTPUT
          echo "covered-lines=$COVERED_LINES" >> $GITHUB_OUTPUT

      # Step 6: Comment on PR with coverage summary
      - name: Comment coverage summary on PR
        if: steps.changed-packages.outputs.has-changes == 'true' && steps.coverage-summary.outputs.coverage-pct != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const coveragePct = '${{ steps.coverage-summary.outputs.coverage-pct }}';
            const totalLines = '${{ steps.coverage-summary.outputs.total-lines }}';
            const coveredLines = '${{ steps.coverage-summary.outputs.covered-lines }}';
            const serviceAreas = '${{ steps.service-area.outputs.service-areas }}';

            const body = `## ðŸ“Š Unit Test Coverage Report

            **Coverage for Changed Packages:** ${coveragePct}%

            - **Total Lines:** ${totalLines}
            - **Covered Lines:** ${coveredLines}
            - **Service Areas:** ${serviceAreas || 'N/A'}

            > Note: This is unit test coverage only. Full acceptance test coverage is run bi-weekly and includes integration with Microsoft Graph API.

            [View detailed coverage report on Codecov](https://codecov.io/gh/${{ github.repository }}/pull/${{ github.event.pull_request.number }})
            `;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Unit Test Coverage Report')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Skip - No Go changes
        if: steps.changed-packages.outputs.has-changes == 'false'
        run: |
          echo "No Go files changed, skipping coverage report"
