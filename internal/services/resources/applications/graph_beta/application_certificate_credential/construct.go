package graphBetaApplicationCertificateCredential

import (
	"context"
	"fmt"

	"github.com/deploymenttheory/terraform-provider-microsoft365/internal/services/common/constructors"
	"github.com/deploymenttheory/terraform-provider-microsoft365/internal/services/common/convert"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	graphmodels "github.com/microsoftgraph/msgraph-beta-sdk-go/models"
)

// constructResource constructs the application PATCH request body with keyCredentials.
// If replaceExisting is false, existing credentials are preserved and the new one is added.
// If replaceExisting is true, all existing credentials are replaced with just the new one.
func constructResource(ctx context.Context, data *ApplicationCertificateCredentialResourceModel, existingCredentials []any) (graphmodels.Applicationable, error) {
	tflog.Debug(ctx, fmt.Sprintf("Constructing %s resource from model", ResourceName))

	application := graphmodels.NewApplication()

	// Build the new key credential
	// Note: keyId is NOT set - it's generated by the API
	newCredential := graphmodels.NewKeyCredential()

	keyBytes, err := decodeCertificateKey(data.Key.ValueString(), data.Encoding.ValueString())
	if err != nil {
		return nil, fmt.Errorf("failed to decode certificate key: %w", err)
	}
	newCredential.SetKey(keyBytes)

	convert.FrameworkToGraphString(data.KeyType, newCredential.SetTypeEscaped)
	convert.FrameworkToGraphString(data.Usage, newCredential.SetUsage)
	convert.FrameworkToGraphString(data.DisplayName, newCredential.SetDisplayName)

	if err := convert.FrameworkToGraphTime(data.StartDateTime, newCredential.SetStartDateTime); err != nil {
		return nil, fmt.Errorf("failed to parse start_date_time: %w", err)
	}

	if err := convert.FrameworkToGraphTime(data.EndDateTime, newCredential.SetEndDateTime); err != nil {
		return nil, fmt.Errorf("failed to parse end_date_time: %w", err)
	}

	// Build the keyCredentials array
	var keyCredentials []graphmodels.KeyCredentialable

	replaceExisting := data.ReplaceExistingCertificates.ValueBool()
	if !replaceExisting && len(existingCredentials) > 0 {
		tflog.Debug(ctx, fmt.Sprintf("Preserving %d existing key credentials", len(existingCredentials)))
		for _, cred := range existingCredentials {
			if keyCred, ok := cred.(graphmodels.KeyCredentialable); ok {
				keyCredentials = append(keyCredentials, keyCred)
			}
		}
	} else if replaceExisting {
		tflog.Debug(ctx, "Replacing all existing key credentials")
	}
	keyCredentials = append(keyCredentials, newCredential)

	application.SetKeyCredentials(keyCredentials)

	if err := constructors.DebugLogGraphObject(ctx, fmt.Sprintf("Final JSON to be sent to Graph API for resource %s", ResourceName), application); err != nil {
		tflog.Error(ctx, "Failed to debug log object", map[string]any{
			"error": err.Error(),
		})
	}

	tflog.Debug(ctx, fmt.Sprintf("Finished constructing %s resource with %d total credentials", ResourceName, len(keyCredentials)))

	return application, nil
}

// constructDeleteResource constructs the application PATCH request body to remove a specific key credential.
// It preserves all other credentials except the one being deleted.
func constructDeleteResource(ctx context.Context, keyIDToRemove string, existingCredentials []graphmodels.KeyCredentialable) (graphmodels.Applicationable, error) {
	tflog.Debug(ctx, fmt.Sprintf("Constructing delete request for key_id: %s", keyIDToRemove))

	application := graphmodels.NewApplication()

	// Build the keyCredentials array without the credential being deleted
	var keyCredentials []graphmodels.KeyCredentialable

	for _, cred := range existingCredentials {
		if cred.GetKeyId() != nil && cred.GetKeyId().String() != keyIDToRemove {
			keyCredentials = append(keyCredentials, cred)
		}
	}

	tflog.Debug(ctx, fmt.Sprintf("Preserving %d credentials after removing key_id: %s", len(keyCredentials), keyIDToRemove))

	application.SetKeyCredentials(keyCredentials)

	if err := constructors.DebugLogGraphObject(ctx, "Delete request body", application); err != nil {
		tflog.Error(ctx, "Failed to debug log object", map[string]any{
			"error": err.Error(),
		})
	}

	return application, nil
}
