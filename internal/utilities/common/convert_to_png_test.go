package common

import (
	"context"
	"os"
	"path/filepath"
	"testing"
)

func TestConvertToPNG(t *testing.T) {
	// Create a simple JPEG image for testing
	jpegData := []byte{
		0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
		0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
		0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01, 0x00,
		0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3F,
		0x00, 0xFF, 0xD9,
	}

	// Create a simple PNG image for testing
	pngData := []byte{
		0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
		0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
		0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
		0x0A, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
		0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x49,
		0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82,
	}

	ctx := context.Background()

	tests := []struct {
		name      string
		input     []byte
		isPNG     bool
		expectErr bool
	}{
		{
			name:      "JPEG to PNG",
			input:     jpegData,
			isPNG:     false,
			expectErr: true, // This minimal JPEG is likely invalid, so we expect an error
		},
		{
			name:      "PNG remains PNG",
			input:     pngData,
			isPNG:     true,
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Skip actual conversion test if we expect an error
			if tt.expectErr {
				_, err := ConvertToPNG(ctx, tt.input)
				if err == nil {
					t.Errorf("ConvertToPNG() expected error but got nil")
				}
				return
			}

			// Test conversion
			result, err := ConvertToPNG(ctx, tt.input)
			if err != nil {
				t.Fatalf("ConvertToPNG() error = %v", err)
			}

			// Check if result is PNG
			if !IsPNG(result) {
				t.Errorf("ConvertToPNG() result is not PNG")
			}
		})
	}
}

func TestIsPNG(t *testing.T) {
	tests := []struct {
		name     string
		data     []byte
		expected bool
	}{
		{
			name:     "Valid PNG",
			data:     []byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00},
			expected: true,
		},
		{
			name:     "Not PNG",
			data:     []byte{0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46},
			expected: false,
		},
		{
			name:     "Empty data",
			data:     []byte{},
			expected: false,
		},
		{
			name:     "Too short",
			data:     []byte{0x89, 0x50, 0x4E, 0x47},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := IsPNG(tt.data)
			if result != tt.expected {
				t.Errorf("IsPNG() = %v, want %v", result, tt.expected)
			}
		})
	}
}

func TestGetImageFormat(t *testing.T) {
	// This test is limited because the test data is minimal
	// and might not be valid for actual format detection
	tests := []struct {
		name      string
		data      []byte
		expectErr bool
	}{
		{
			name:      "PNG header",
			data:      []byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00},
			expectErr: true, // This minimal PNG header is likely invalid
		},
		{
			name:      "Empty data",
			data:      []byte{},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := GetImageFormat(tt.data)
			if (err != nil) != tt.expectErr {
				t.Errorf("GetImageFormat() error = %v, expectErr %v", err, tt.expectErr)
			}
		})
	}
}

func TestSaveImageAsPNG(t *testing.T) {
	// Create a temporary directory for test files
	tempDir, err := os.MkdirTemp("", "image_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create a simple PNG for testing
	pngData := []byte{
		0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
		0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
		0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
		0x0A, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
		0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x49,
		0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82,
	}

	outputPath := filepath.Join(tempDir, "test.png")

	// Test saving PNG data
	err = SaveImageAsPNG(pngData, outputPath)
	if err != nil {
		t.Fatalf("SaveImageAsPNG() error = %v", err)
	}

	// Check if file exists
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Errorf("SaveImageAsPNG() did not create file")
	}

	// Read the file back and check if it's still a PNG
	savedData, err := os.ReadFile(outputPath)
	if err != nil {
		t.Fatalf("Failed to read saved file: %v", err)
	}

	if !IsPNG(savedData) {
		t.Errorf("Saved file is not a PNG")
	}
}
